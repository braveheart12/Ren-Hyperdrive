package block

import (
	"fmt"
	"time"

	"github.com/renproject/hyperdrive/sig"
	"github.com/renproject/hyperdrive/tx"
	"golang.org/x/crypto/sha3"
)

// MaxTransactions defines the maximum number of transactions allowed in a block.
const MaxTransactions = 1

// The Round in which a `Block` was proposed.
type Round int64

// The Height at which a `Block` was proposed.
type Height int64

// A Block is the data structure on which consensus must be reached. The Height
// of a Block should be unique to that Block, otherwise the consensus mechanism
// is faulty. A Block stores an ordered list of Transactions that will be
// executed when consensus has been reached on the Block.
type Block struct {
	Time         time.Time
	Height       Height
	Header       sig.Hash
	ParentHeader sig.Hash
	Txs          tx.Transactions
	TxHeader     sig.Hash
}

// New Block with the transaction header, and header, automatically computed and
// stored in the returned Block.
func New(height Height, parentHeader sig.Hash, txs tx.Transactions) Block {
	block := Block{
		Time:         time.Now(),
		Height:       height,
		ParentHeader: parentHeader,
		Txs:          txs,
	}
	txHeaders := make([]byte, 32*len(block.Txs))
	for i, tx := range block.Txs {
		copy(txHeaders[32*i:], tx[:])
	}
	block.TxHeader = sha3.Sum256(txHeaders)
	block.Header = sha3.Sum256([]byte(block.String()))
	return block
}

// Equal checks for equality between the heights,  headers, and parent headers.
func (block Block) Equal(other Block) bool {
	return block.Height == other.Height &&
		block.Header.Equal(other.Header) &&
		block.ParentHeader.Equal(other.ParentHeader)
}

// Sign the header of the Block.
func (block Block) Sign(signer sig.Signer) (SignedBlock, error) {
	signedBlock := SignedBlock{
		Block: block,
	}

	signature, err := signer.Sign(signedBlock.Header)
	if err != nil {
		return SignedBlock{}, err
	}
	signedBlock.Signature = signature
	signedBlock.Signatory = signer.Signatory()

	return signedBlock, nil
}

// String implements the Stringer interface for the Block type.
func (block Block) String() string {
	return fmt.Sprintf("Block(Height=%d,Timestamp=%d,TxHeader=%s,ParentHeader=%s)", block.Height, block.Time.Unix(), block.TxHeader, block.ParentHeader)
}

// A SignedBlock is a Block associated with a Signature and a Signatory. The
// Signature is generated by signing the Block header.
type SignedBlock struct {
	Block

	Signature sig.Signature
	Signatory sig.Signatory
}

// Genesis returns the genesis SignedBlock. The Signature and Signatory is
// empty, and all other values are non-nil zero values.
func Genesis() SignedBlock {
	return SignedBlock{
		Block: Block{
			Time:         time.Unix(0, 0),
			Height:       0,
			Header:       sig.Hash{},
			ParentHeader: sig.Hash{},
			Txs:          tx.Transactions{},
		},
		Signature: sig.Signature{},
		Signatory: sig.Signatory{},
	}
}

// String implements the Stringer interface for the SignedBlock type.
func (signedBlock SignedBlock) String() string {
	return fmt.Sprintf("Block(Height=%d,Timestamp=%d,TxHeader=%s,ParentHeader=%s,Header=%s)", signedBlock.Height, signedBlock.Time.Unix(), signedBlock.TxHeader, signedBlock.ParentHeader, signedBlock.Header)
}

type Propose struct {
	Block      SignedBlock
	Round      Round
	ValidRound Round // TODO: (Review) This name comes from the pseudocode in (https://arxiv.org/pdf/1807.04938.pdf). Should this be renamed to something more appropriate?
	LastCommit *Commit
}

// Sign a Propose with your private key
func (propose Propose) Sign(signer sig.Signer) (SignedPropose, error) {
	data := []byte(propose.String())

	hashSum256 := sha3.Sum256(data)
	hash := sig.Hash{}
	copy(hash[:], hashSum256[:])

	signature, err := signer.Sign(hash)
	if err != nil {
		return SignedPropose{}, err
	}

	return SignedPropose{
		Propose:   propose,
		Signature: signature,
		Signatory: signer.Signatory(),
	}, nil
}

func (propose Propose) String() string {
	return fmt.Sprintf("Propose(Block=%s,Round=%d,ValidRound=%d)", propose.Block.String(), propose.Round, propose.ValidRound)
}

type SignedPropose struct {
	Propose

	Signature sig.Signature
	Signatory sig.Signatory
}

type Blockchain struct {
	store Store
}

func NewBlockchain(store Store) Blockchain {
	return Blockchain{
		store: store,
	}
}

func (blockchain *Blockchain) Height() Height {
	height, err := blockchain.store.Height()
	if err != nil {
		return Genesis().Height
	}
	return height
}

func (blockchain *Blockchain) Head() (Commit, bool) {
	return blockchain.Block(blockchain.Height())
}

func (blockchain *Blockchain) Block(height Height) (Commit, bool) {
	commit, err := blockchain.store.Block(height)
	if err != nil || commit.Polka.Block == nil {
		genesis := Genesis()
		return Commit{Polka: Polka{Block: &genesis}}, false
	}
	return commit, true
}

func (blockchain *Blockchain) Extend(commitToNextBlock Commit) error {
	if commitToNextBlock.Polka.Block == nil {
		return nil
	}
	if commitToNextBlock.Polka.Block.Height < blockchain.Height() {
		panic("invariant violation: insert block before latest height")
	}
	return blockchain.store.InsertBlock(commitToNextBlock)
}

func (blockchain *Blockchain) Blocks(begin, end Height) []Commit {
	if end < begin {
		return []Commit{}
	}

	var block Commit
	var err error

	blocks := make([]Commit, 0, end-begin)
	for i := begin; i <= end; i++ {
		if block, err = blockchain.store.Block(i); err != nil || block.Polka.Block == nil {
			return blocks
		}
		blocks = append(blocks, block)
	}
	return blocks
}

type Store interface {

	// InsertBlock stores a committed SignedBlock to persistent storage.
	InsertBlock(commit Commit) error

	// Block returns a committed SignedBlock from persistent storage. An error
	// is returned when there is no SignedBlock committed at the given Height.
	Block(height Height) (Commit, error)

	// Height returns the latest Height that has been seen when inserting a
	// Block. An error is returned when there is no Height.
	Height() (Height, error)
}
